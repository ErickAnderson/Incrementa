/**
 * DeepCore Driller - A showcase of the Incrementa framework
 *
 * This game demonstrates the following Incrementa features:
 * - Resource management with capacity limits
 * - Timed production with Miners and Factories
 * - Storage systems with overflow protection
 * - Upgrade system with conditional unlocks
 * - Event-driven architecture
 * - Win conditions and game progression
 */

// Import styles
import "./style.css";

// Import Incrementa framework components
import {
  Game,
  Upgrade,
  SaveManager,
  Resource,
  Miner,
  Factory,
  Storage,
  Building,
} from "../../../dist/incrementa.js";

// Game state object to hold all game entities and data
const gameState = {
  game: null,
  resources: {},
  buildings: {},
  upgrades: {},
  isGameWon: false,
  gameStartTime: Date.now(),
};

/**
 * Initialize the game and all its components
 * This function sets up the complete game state and starts the game loop
 */
function initializeGame() {
  console.log("🎮 Initializing DeepCore Driller...");

  // Create save manager with localStorage for browser storage
  const saveManager = new SaveManager({
    getItem: (key) => localStorage.getItem(key),
    setItem: (key, value) => localStorage.setItem(key, value),
  });

  // Create the main game instance
  gameState.game = new Game(saveManager);

  // Initialize all game systems
  setupResources();
  setupBuildings();
  setupUpgrades();
  setupEventListeners();

  // Start the game loop
  gameState.game.start();

  console.log("✅ Game initialized successfully!");
}
import { setDebugMode } from "../../../dist/incrementa.js";

setDebugMode(false);

/**
 * Define and initialize all game resources
 * This showcases the Resource entity from Incrementa framework
 */
function setupResources() {
  console.log("Setting up resources...");

  // Ore - Basic raw material generated by Miners
  gameState.resources.ore = new Resource({
    id: "ore",
    name: "Ore",
    description:
      "Raw material extracted from the depths. Used to create Metal.",
    initialAmount: 0,
    rate: 0, // No automatic generation, only manual mining and miner buildings
    tags: ["raw-material"],
  });

  // Metal - Refined resource converted from Ore
  gameState.resources.metal = new Resource({
    id: "metal",
    name: "Metal",
    description:
      "Refined Ore ready for advanced construction. Used to build complex structures.",
    initialAmount: 0,
    rate: 0, // Cannot be gathered manually, only produced by Smelter
    unlockCondition: () => gameState.resources.ore.amount >= 5,
    tags: ["refined-material"],
  });

  // Energy - Late-game resource for the win condition
  gameState.resources.energy = new Resource({
    id: "energy",
    name: "Energy",
    description:
      "Pure energy condensed from Metal. Required for the Deepcore Reactor.",
    initialAmount: 0,
    rate: 0, // Only produced by Power Core
    unlockCondition: () => gameState.resources.metal.amount >= 20,
    tags: ["energy"],
  });

  // Set up game references for capacity checking
  Object.values(gameState.resources).forEach((resource) => {
    resource.setGameReference(gameState.game);
    gameState.game.addEntity(resource);
  });

  // Set up real-time UI updates for resources
  Object.values(gameState.resources).forEach((resource) => {
    resource.on("amountChanged", updateResourceDisplay);
    resource.on("unlocked", updateResourceDisplay);
  });

  console.log("✅ Resources initialized:", Object.keys(gameState.resources));
}

/**
 * Define and initialize all game buildings
 * This showcases Miner, Factory, Storage, and custom Building entities
 */
function setupBuildings() {
  console.log("Setting up buildings...");

  // Miner - Automatically extracts Ore from the ground
  gameState.buildings.miner = new Miner({
    id: "miner",
    name: "Miner",
    description:
      "Automated ore extraction machine. Generates Ore continuously.",
    cost: { ore: 10 },
    buildTime: 3,
    gatherRate: 2,
    resourceId: "ore",
    autoStart: false, // Only start production when actually built
    unlockCondition: () => gameState.resources.ore.amount >= 5,
    tags: ["production", "ore-generator"],
  });

  // Smelter (Factory) - Converts Ore into Metal
  gameState.buildings.smelter = new Factory({
    id: "smelter",
    name: "Smelter", 
    description: "Refines raw Ore into valuable Metal.",
    cost: { ore: 25 },
    buildTime: 5,
    inputs: [{ resourceId: "ore", amount: 3 }],
    outputs: [{ resourceId: "metal", amount: 1 }],
    productionRate: 1.0,
    autoStart: false, // Only start when actually built
    unlockCondition: () => gameState.resources.ore.amount >= 15,
    tags: ["production", "conversion"],
  });

  // Power Core (Factory) - Converts Metal into Energy
  gameState.buildings.powerCore = new Factory({
    id: "power-core",
    name: "Power Core",
    description: "Advanced facility that transforms Metal into pure Energy.",
    cost: { ore: 50, metal: 20 },
    buildTime: 10,
    inputs: [{ resourceId: "metal", amount: 2 }],
    outputs: [{ resourceId: "energy", amount: 1 }],
    productionRate: 0.5,
    autoStart: false, // Only start when actually built
    unlockCondition: () => gameState.resources.metal.amount >= 10,
    tags: ["production", "energy-generation"],
  });

  // Storage Unit - Increases capacity for all resources
  gameState.buildings.storage = new Storage({
    id: "storage",
    name: "Storage Unit",
    description: "Expands storage capacity for all resources.",
    cost: { ore: 15, metal: 5 },
    buildTime: 4,
    capacities: {
      ore: 100,
      metal: 50,
      energy: 25,
    },
    unlockCondition: () => gameState.resources.ore.amount >= 20,
    tags: ["infrastructure", "storage"],
  });

  // Deepcore Reactor - Win condition building
  gameState.buildings.deepcoreReactor = new Building({
    id: "deepcore-reactor",
    name: "Deepcore Reactor",
    description:
      "The ultimate drilling achievement! Build this to win the game.",
    cost: { ore: 500, metal: 200, energy: 100 },
    buildTime: 30,
    unlockCondition: () => {
      return (
        gameState.resources.ore.amount >= 100 &&
        gameState.resources.metal.amount >= 50 &&
        gameState.resources.energy.amount >= 25 &&
        (gameState.buildings.miner.level >= 1 || gameState.buildings.miner.isBuilt) &&
        (gameState.buildings.smelter.level >= 1 || gameState.buildings.smelter.isBuilt) &&
        (gameState.buildings.powerCore.level >= 1 || gameState.buildings.powerCore.isBuilt)
      );
    },
    tags: ["win-condition", "ultimate"],
  });

  // Set up game references and register all buildings
  Object.values(gameState.buildings).forEach((building) => {
    // Use setGame for Building class, setGameReference for others
    if (typeof building.setGame === "function") {
      building.setGame(gameState.game);
    } else if (typeof building.setGameReference === "function") {
      building.setGameReference(gameState.game);
    }
    gameState.game.addEntity(building);

    // Listen for building events
    building.on("buildComplete", (data) => {
      console.log(`🏗️ Building completed: ${data.building.name}`);
      
      // Start production for buildings that need it
      if (typeof data.building.startProduction === 'function') {
        data.building.startProduction();
      }
      
      updateBuildingDisplay();
      updateResourceDisplay();

      // Special handling for win condition
      if (data.building.id === "deepcore-reactor") {
        triggerWinCondition();
      }
    });

    building.on("unlocked", updateBuildingDisplay);
    building.on("built", updateBuildingDisplay);
  });

  console.log("✅ Buildings initialized:", Object.keys(gameState.buildings));
}

/**
 * Define and initialize all game upgrades
 * This showcases the Upgrade entity with conditional unlocks and permanent effects
 */
function setupUpgrades() {
  console.log("Setting up upgrades...");

  // Drill Efficiency - Increases Ore production rate for Miners
  gameState.upgrades.drillEfficiency = new Upgrade({
    id: "drill-efficiency",
    name: "Drill Efficiency",
    description: "Improves mining equipment, increasing Ore production by 50%.",
    cost: { ore: 50, metal: 10 },
    unlockCondition: () => {
      return (
        gameState.buildings.miner.level >= 2 &&
        gameState.resources.metal.amount >= 5
      );
    },
    effect: () => {
      const miners = gameState.game.entities.get("miner");
      if (miners) {
        const currentRate = miners.gatherRate;
        miners.setGatherRate(currentRate * 1.5);
        console.log(
          `Drill Efficiency applied: Miner rate increased to ${miners.gatherRate}`
        );
      }
    },
    tags: ["production", "efficiency"],
  });

  // Smelting Speed - Increases Metal production rate for Smelters
  gameState.upgrades.smeltingSpeed = new Upgrade({
    id: "smelting-speed",
    name: "Smelting Speed",
    description:
      "Advanced furnace technology increases Metal production by 40%.",
    cost: { ore: 80, metal: 25 },
    unlockCondition: () => {
      return (
        gameState.buildings.smelter.level >= 1 &&
        gameState.resources.metal.amount >= 15
      );
    },
    effect: () => {
      const smelter = gameState.buildings.smelter;
      if (smelter && smelter.productionConfig) {
        smelter.setFactoryProductionRate(
          smelter.productionConfig.rate.base * 1.4
        );
        console.log(`Smelting Speed applied: Smelter rate increased`);
      }
    },
    tags: ["production", "efficiency"],
  });

  // Storage Optimization - Increases capacity for all Storage Units
  gameState.upgrades.storageOptimization = new Upgrade({
    id: "storage-optimization",
    name: "Storage Optimization",
    description:
      "Better organization doubles the capacity of all Storage Units.",
    cost: { ore: 100, metal: 40, energy: 10 },
    unlockCondition: () => {
      return (
        gameState.buildings.storage.level >= 1 &&
        gameState.resources.energy.amount >= 5
      );
    },
    effect: () => {
      const storage = gameState.buildings.storage;
      if (storage) {
        const currentCapacities = storage.getManagedResourceIds();
        currentCapacities.forEach((resourceId) => {
          const currentCapacity = storage.getCapacityFor(resourceId) || 0;
          storage.setCapacityFor(resourceId, currentCapacity * 2);
        });
        console.log(`Storage Optimization applied: All capacities doubled`);
      }
    },
    tags: ["infrastructure", "capacity"],
  });

  // Set up game references and register all upgrades
  Object.values(gameState.upgrades).forEach((upgrade) => {
    gameState.game.addEntity(upgrade);
    upgrade.on("unlocked", updateUpgradeDisplay);
  });

  console.log("✅ Upgrades initialized:", Object.keys(gameState.upgrades));
}

/**
 * Update the resource display in the UI using DOM manipulation
 * Now includes production rates and progress bars
 */
function updateResourceDisplay() {
  Object.values(gameState.resources).forEach((resource) => {
    const resourceElement = document.getElementById(`${resource.id}-resource`);
    const amountElement = document.getElementById(`${resource.id}-amount`);
    const rateElement = document.getElementById(`${resource.id}-rate`);
    const capacityElement = document.getElementById(`${resource.id}-capacity`);
    const progressElement = document.getElementById(`${resource.id}-progress`);

    if (!resourceElement || !amountElement) return;

    // Ore is always visible, others show when unlocked
    if (resource.id === "ore" || resource.isUnlocked) {
      // Show the resource
      resourceElement.style.display = "block";

      // Update amount
      amountElement.textContent = Math.floor(resource.amount);

      // Update production rate
      if (rateElement) {
        const productionRate = calculateProductionRate(resource.id);
        rateElement.textContent =
          productionRate > 0 ? `+${productionRate.toFixed(1)}/sec` : "+0/sec";
      }

      // Update capacity info and progress bar
      const totalCapacity =
        gameState.game?.getTotalCapacityFor(resource.id) || 0;
      if (totalCapacity > 0) {
        const utilization = (resource.amount / totalCapacity) * 100;
        if (capacityElement) {
          capacityElement.textContent = `${Math.floor(
            resource.amount
          )}/${totalCapacity}`;
        }
        if (progressElement) {
          progressElement.style.width = `${Math.min(utilization, 100)}%`;
        }
      } else {
        if (capacityElement) {
          capacityElement.textContent = "Unlimited";
        }
        if (progressElement) {
          progressElement.style.width = "0%";
        }
      }
    } else {
      // Hide the resource
      resourceElement.style.display = "none";
    }
  });
}

/**
 * Calculate the current production rate for a resource
 * Uses the framework's built-in production tracking
 */
function calculateProductionRate(resourceId) {
  // Try to get production rate from the game's resource tracking
  const resource = gameState.resources[resourceId];
  if (resource && typeof resource.getProductionRate === 'function') {
    return resource.getProductionRate();
  }
  
  // Fallback: check if game has production tracking
  if (gameState.game && typeof gameState.game.getProductionRateFor === 'function') {
    return gameState.game.getProductionRateFor(resourceId);
  }
  
  // Last resort: return 0 for now, let framework handle it
  return 0;
}

/**
 * Update the building display in the UI using DOM manipulation
 */
function updateBuildingDisplay() {
  const noBuildingsMessage = document.getElementById("no-buildings");
  let hasVisibleBuildings = false;

  Object.values(gameState.buildings).forEach((building) => {
    const buildingElement = document.getElementById(`${building.id}-building`);
    const countElement = document.getElementById(`${building.id}-count`);
    const buttonElement = document.getElementById(`${building.id}-button`);
    const progressElement = document.getElementById(`${building.id}-progress`);

    if (!buildingElement || !countElement || !buttonElement) return;

    if (building.isUnlocked) {
      // Show the building
      buildingElement.style.display = "block";
      hasVisibleBuildings = true;

      // Only count buildings that are actually built, not just unlocked
      const buildingCount = (building.isBuilt) ? (building.level || 1) : 0;
      countElement.textContent = `x${buildingCount}`;

      // Update button state
      const canAfford = canAffordBuilding(building);
      const isBuilding = building.isBuilding;

      // Define original color schemes for each building
      const originalColors = {
        'miner': { main: 'bg-green-600', hover: 'hover:bg-green-500' },
        'smelter': { main: 'bg-orange-600', hover: 'hover:bg-orange-500' },
        'power-core': { main: 'bg-purple-600', hover: 'hover:bg-purple-500' },
        'storage': { main: 'bg-blue-600', hover: 'hover:bg-blue-500' },
        'deepcore-reactor': { main: 'bg-gradient-to-r from-red-600 to-pink-600', hover: 'hover:from-red-500 hover:to-pink-500' }
      };

      const colors = originalColors[building.id] || { main: 'bg-gray-600', hover: 'hover:bg-gray-500' };

      if (canAfford && !isBuilding) {
        // Remove disabled state and restore original colors
        buttonElement.classList.remove("bg-gray-600", "cursor-not-allowed");
        buttonElement.classList.add(...colors.main.split(' '), ...colors.hover.split(' '));
        buttonElement.disabled = false;
        buttonElement.textContent = "Build";
      } else {
        // Remove enabled colors and add disabled state
        Object.values(originalColors).forEach(colorSet => {
          buttonElement.classList.remove(...colorSet.main.split(' '), ...colorSet.hover.split(' '));
        });
        buttonElement.classList.add("bg-gray-600", "cursor-not-allowed");
        buttonElement.disabled = true;
        buttonElement.textContent = isBuilding ? "Building..." : "Build";
      }

      // Update progress display
      if (progressElement) {
        if (isBuilding && building.buildTimer) {
          const progress = (
            ((building.buildTime - building.buildTimer.getTimeRemaining()) /
              building.buildTime) *
            100
          ).toFixed(1);
          progressElement.textContent = `Building... ${progress}%`;
          progressElement.style.display = "block";
        } else {
          progressElement.style.display = "none";
        }
      }
    } else {
      // Hide the building
      buildingElement.style.display = "none";
    }
  });

  // Show/hide no buildings message
  if (noBuildingsMessage) {
    noBuildingsMessage.style.display = hasVisibleBuildings ? "none" : "block";
  }
}

/**
 * Update the upgrade display in the UI using DOM manipulation
 */
function updateUpgradeDisplay() {
  const noUpgradesMessage = document.getElementById("no-upgrades");
  let hasVisibleUpgrades = false;

  Object.values(gameState.upgrades).forEach((upgrade) => {
    const upgradeElement = document.getElementById(`${upgrade.id}-upgrade`);
    const buttonElement = document.getElementById(`${upgrade.id}-button`);

    if (!upgradeElement || !buttonElement) return;

    if (upgrade.isUnlocked && !upgrade.purchased) {
      // Show the upgrade
      upgradeElement.style.display = "block";
      hasVisibleUpgrades = true;

      // Update button state
      const canAfford = canAffordUpgrade(upgrade);

      if (canAfford) {
        // Remove disabled state and restore original indigo colors
        buttonElement.classList.remove("bg-gray-600", "cursor-not-allowed");
        buttonElement.classList.add("bg-indigo-600", "hover:bg-indigo-500");
        buttonElement.disabled = false;
      } else {
        // Remove enabled state and add disabled colors
        buttonElement.classList.remove("bg-indigo-600", "hover:bg-indigo-500");
        buttonElement.classList.add("bg-gray-600", "cursor-not-allowed");
        buttonElement.disabled = true;
      }
    } else {
      // Hide the upgrade
      upgradeElement.style.display = "none";
    }
  });

  // Show/hide no upgrades message
  if (noUpgradesMessage) {
    noUpgradesMessage.style.display = hasVisibleUpgrades ? "none" : "block";
  }
}

/**
 * Check if player can afford a building
 */
function canAffordBuilding(building) {
  // Use the Building class's built-in canAfford method if available
  if (typeof building.canAfford === 'function') {
    return building.canAfford();
  }

  // Fallback: use getCosts() method for modern Building class
  if (typeof building.getCosts === 'function') {
    const costs = building.getCosts();
    if (!costs || costs.length === 0) return true;

    for (const costDef of costs) {
      const resource = gameState.resources[costDef.resourceId];
      if (!resource || resource.amount < costDef.amount) {
        return false;
      }
    }
    return true;
  }

  // Legacy fallback for direct cost property
  if (!building.cost) return true;

  for (const [resourceId, amount] of Object.entries(building.cost)) {
    const resource = gameState.resources[resourceId];
    if (!resource || resource.amount < amount) {
      return false;
    }
  }
  return true;
}

/**
 * Check if player can afford an upgrade
 */
function canAffordUpgrade(upgrade) {
  if (!upgrade.cost) return true;

  for (const [resourceId, amount] of Object.entries(upgrade.cost)) {
    const resource = gameState.resources[resourceId];
    if (!resource || resource.amount < amount) {
      return false;
    }
  }
  return true;
}

/**
 * Build a building (called from UI button clicks)
 */
function buildBuilding(buildingId) {
  const building = gameState.buildings[buildingId];
  if (!building) {
    return;
  }

  if (building.isBuilding) {
    return;
  }

  // Check if we can afford it
  if (!canAffordBuilding(building)) {
    return;
  }

  // Start construction - this automatically handles cost validation and resource spending
  const success = building.startConstruction();

  if (success) {
    updateBuildingDisplay();
    updateResourceDisplay();
  }
}

/**
 * Purchase an upgrade (called from UI button clicks)
 */
function purchaseUpgrade(upgradeId) {
  const upgrade = gameState.upgrades[upgradeId];
  if (!upgrade) return;

  if (!canAffordUpgrade(upgrade) || upgrade.purchased) {
    return;
  }

  // Deduct costs
  if (upgrade.cost) {
    for (const [resourceId, amount] of Object.entries(upgrade.cost)) {
      const resource = gameState.resources[resourceId];
      if (resource) {
        resource.decrement(amount);
      }
    }
  }

  // Apply the upgrade
  upgrade.apply();
  upgrade.purchased = true;

  updateUpgradeDisplay();
  updateResourceDisplay();
  updateBuildingDisplay();

  console.log(`Upgrade purchased: ${upgrade.name}`);
}

/**
 * Trigger win condition
 */
function triggerWinCondition() {
  gameState.isGameWon = true;
  const completionTime = Math.floor(
    (Date.now() - gameState.gameStartTime) / 1000
  );
  const minutes = Math.floor(completionTime / 60);
  const seconds = completionTime % 60;

  const completionTimeElement = document.getElementById("completion-time");
  const winScreenElement = document.getElementById("win-screen");

  if (completionTimeElement) {
    completionTimeElement.textContent = `${minutes}:${seconds
      .toString()
      .padStart(2, "0")}`;
  }

  if (winScreenElement) {
    winScreenElement.style.display = "flex";
  }

  console.log("🎉 Game Won! Deepcore Reactor completed!");
}

function setupEventListeners() {
  console.log("Setting up event listeners...");

  // Make functions globally available for button clicks
  window.buildBuilding = buildBuilding;
  window.purchaseUpgrade = purchaseUpgrade;

  // Manual mining button
  const mineButton = document.getElementById("mine-button");
  if (mineButton) {
    mineButton.addEventListener("click", () => {
      const oreResource = gameState.resources.ore;
      if (oreResource) {
        const mined = oreResource.increment(1); // Mine 1 ore per click
        if (mined) {
          // Visual feedback for successful mining
          mineButton.classList.add("btn-success-feedback");
          setTimeout(() => {
            mineButton.classList.remove("btn-success-feedback");
          }, 300);
        } else {
          // Visual feedback for capacity limit reached
          mineButton.classList.add("btn-error-feedback");
          setTimeout(() => {
            mineButton.classList.remove("btn-error-feedback");
          }, 300);
        }
      }
    });
  }

  // Set up button event listeners for buildings
  Object.keys(gameState.buildings).forEach((buildingId) => {
    const buttonElement = document.getElementById(`${buildingId}-button`);
    if (buttonElement) {
      buttonElement.addEventListener("click", () => buildBuilding(buildingId));
    }
  });

  // Set up button event listeners for upgrades
  Object.keys(gameState.upgrades).forEach((upgradeId) => {
    const buttonElement = document.getElementById(`${upgradeId}-button`);
    if (buttonElement) {
      buttonElement.addEventListener("click", () => purchaseUpgrade(upgradeId));
    }
  });

  // Set up periodic UI updates to show real-time changes
  setInterval(() => {
    updateResourceDisplay();
    updateBuildingDisplay();
    updateUpgradeDisplay();
  }, 1000); // Update every second

  // Initial UI update
  updateResourceDisplay();
  updateBuildingDisplay();
  updateUpgradeDisplay();
}

// Initialize the game when the page loads
document.addEventListener("DOMContentLoaded", initializeGame);
